{"ast":null,"code":"const isDefined = value => value !== null && value !== undefined;\nconst mergeDefined = (base, extension) => {\n  const merged = {\n    ...base\n  };\n  Object.keys(extension).forEach(key => {\n    const value = extension[key];\n    if (isDefined(value)) {\n      merged[key] = value;\n    }\n  });\n  return merged;\n};\nconst mergeOptions = (base, extension) => {\n  if (!base && !extension) return undefined;\n  return {\n    ...(base !== null && base !== void 0 ? base : {}),\n    ...(extension !== null && extension !== void 0 ? extension : {})\n  };\n};\nexport const createRegistry = initial => ({\n  ...(initial !== null && initial !== void 0 ? initial : {})\n});\nexport const addRules = (registry, rules) => {\n  Object.keys(rules).forEach(name => {\n    registry[name] = rules[name];\n  });\n};\nexport const resolveRule = (registry, name, overrides) => {\n  const visited = new Set();\n  const resolveRecursive = ruleName => {\n    if (visited.has(ruleName)) {\n      throw new Error(`Pliant: circular rule inheritance detected for \"${ruleName}\".`);\n    }\n    const base = registry[ruleName];\n    if (!base) {\n      throw new Error(`Pliant: rule \"${ruleName}\" is not registered.`);\n    }\n    visited.add(ruleName);\n    let resolved = {\n      ...base,\n      name: ruleName\n    };\n    if (base.inherit) {\n      const inherited = resolveRecursive(base.inherit);\n      resolved = mergeDefined(inherited, resolved);\n      resolved.options = mergeOptions(inherited.options, resolved.options);\n    }\n    return resolved;\n  };\n  let resolved = resolveRecursive(name);\n  if (overrides) {\n    resolved = mergeDefined(resolved, overrides);\n    resolved.options = mergeOptions(resolved.options, overrides.options);\n  }\n  if (!resolved.validate) {\n    throw new Error(`Pliant: rule \"${name}\" does not define a validate function.`);\n  }\n  return resolved;\n};\nexport const toRuleRef = ref => {\n  if (typeof ref === \"string\") {\n    return {\n      name: ref\n    };\n  }\n  if (Array.isArray(ref)) {\n    return {\n      name: ref[0],\n      options: ref[1]\n    };\n  }\n  return ref;\n};\nexport const resolveRuleRef = (registry, ref) => {\n  const {\n    name,\n    options,\n    message,\n    enabled\n  } = toRuleRef(ref);\n  const resolved = resolveRule(registry, name, {\n    options,\n    enabled\n  });\n  return {\n    ...resolved,\n    messageOverride: message\n  };\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}