{"ast":null,"code":"import _asyncToGenerator from \"/Users/portablesheep/repos/Pliant/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { resolveRuleRef } from \"./registry\";\nconst applyMessage = (detail, ctx, message) => {\n  if (!message || detail.message) return detail;\n  return {\n    ...detail,\n    message: typeof message === \"function\" ? message(detail, ctx) : message\n  };\n};\nconst createErrorDetail = (code, detail) => ({\n  code,\n  ...(detail !== null && detail !== void 0 ? detail : {})\n});\nexport const evaluateRule = (registry, value, ctx, ref) => {\n  var _a, _b;\n  const resolved = resolveRuleRef(registry, ref);\n  if (resolved.enabled === false) return null;\n  const result = resolved.validate(value, ctx, (_a = resolved.options) !== null && _a !== void 0 ? _a : {});\n  if (!result) return null;\n  const detail = createErrorDetail(resolved.name, result);\n  const message = (_b = resolved.messageOverride) !== null && _b !== void 0 ? _b : resolved.message;\n  return applyMessage(detail, ctx, message);\n};\nexport const evaluateRules = (registry, value, ctx, rules) => {\n  const errors = {};\n  for (const ref of rules) {\n    const detail = evaluateRule(registry, value, ctx, ref);\n    if (detail) {\n      errors[detail.code] = detail;\n    }\n  }\n  return Object.keys(errors).length > 0 ? errors : null;\n};\nexport const evaluateRulesAsync = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (registry, value, ctx, rules) {\n    var _a, _b, _c, _d;\n    const errors = {};\n    for (const ref of rules) {\n      const resolved = resolveRuleRef(registry, ref);\n      if (resolved.enabled === false) continue;\n      if (resolved.validateAsync) {\n        const result = yield resolved.validateAsync(value, ctx, (_a = resolved.options) !== null && _a !== void 0 ? _a : {});\n        if (result) {\n          const detail = createErrorDetail(resolved.name, result);\n          const message = (_b = resolved.messageOverride) !== null && _b !== void 0 ? _b : resolved.message;\n          errors[detail.code] = applyMessage(detail, ctx, message);\n        }\n      } else {\n        const result = resolved.validate(value, ctx, (_c = resolved.options) !== null && _c !== void 0 ? _c : {});\n        if (result) {\n          const detail = createErrorDetail(resolved.name, result);\n          const message = (_d = resolved.messageOverride) !== null && _d !== void 0 ? _d : resolved.message;\n          errors[detail.code] = applyMessage(detail, ctx, message);\n        }\n      }\n    }\n    return Object.keys(errors).length > 0 ? errors : null;\n  });\n  return function evaluateRulesAsync(_x, _x2, _x3, _x4) {\n    return _ref.apply(this, arguments);\n  };\n}();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}