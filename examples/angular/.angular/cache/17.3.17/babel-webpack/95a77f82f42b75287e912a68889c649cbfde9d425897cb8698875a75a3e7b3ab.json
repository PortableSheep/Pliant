{"ast":null,"code":"import _asyncToGenerator from \"/Users/portablesheep/repos/Pliant/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { inject } from \"@angular/core\";\nimport { applyMessages, createMessageResolver, createRegistry, evaluateRules, evaluateRulesAsync } from \"@pliant/core\";\nimport { PLIANT_MESSAGES, PLIANT_RULES } from \"./providers\";\nconst buildRegistry = registries => {\n  const registry = createRegistry();\n  (registries !== null && registries !== void 0 ? registries : []).forEach(entry => {\n    Object.assign(registry, entry);\n  });\n  return registry;\n};\nconst toResolver = provider => {\n  return typeof provider === \"function\" ? provider : createMessageResolver(provider);\n};\nconst buildMessageResolver = providers => {\n  if (!providers || providers.length === 0) return undefined;\n  const resolvers = providers.map(toResolver);\n  return (code, detail, ctx) => {\n    for (let i = resolvers.length - 1; i >= 0; i -= 1) {\n      const message = resolvers[i](code, detail, ctx);\n      if (message) return message;\n    }\n    return undefined;\n  };\n};\nconst createContext = (control, field) => ({\n  field,\n  data: control.parent ? control.parent.value : undefined\n});\nexport const pliant = (rules, options) => {\n  const registries = inject(PLIANT_RULES, {\n    optional: true\n  });\n  const registry = buildRegistry(registries);\n  const messageProviders = inject(PLIANT_MESSAGES, {\n    optional: true\n  });\n  const messageResolver = buildMessageResolver(messageProviders);\n  return control => {\n    const ctx = createContext(control, options === null || options === void 0 ? void 0 : options.field);\n    const errors = evaluateRules(registry, control.value, ctx, rules);\n    const resolved = applyMessages(errors, ctx, messageResolver);\n    return resolved ? {\n      pliant: resolved\n    } : null;\n  };\n};\nexport const pliantAsync = (rules, options) => {\n  const registries = inject(PLIANT_RULES, {\n    optional: true\n  });\n  const registry = buildRegistry(registries);\n  const messageProviders = inject(PLIANT_MESSAGES, {\n    optional: true\n  });\n  const messageResolver = buildMessageResolver(messageProviders);\n  return /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator(function* (control) {\n      const ctx = createContext(control, options === null || options === void 0 ? void 0 : options.field);\n      const errors = yield evaluateRulesAsync(registry, control.value, ctx, rules);\n      const resolved = applyMessages(errors, ctx, messageResolver);\n      return resolved ? {\n        pliant: resolved\n      } : null;\n    });\n    return function (_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n};\nexport const pliantGroup = ruleset => {\n  const registries = inject(PLIANT_RULES, {\n    optional: true\n  });\n  const registry = buildRegistry(registries);\n  const messageProviders = inject(PLIANT_MESSAGES, {\n    optional: true\n  });\n  const messageResolver = buildMessageResolver(messageProviders);\n  return control => {\n    if (!control || !control.value || typeof control.value !== \"object\") {\n      return null;\n    }\n    const groupErrors = {};\n    if (ruleset.group && ruleset.group.length > 0) {\n      const ctx = createContext(control, \"$group\");\n      const errors = evaluateRules(registry, control.value, ctx, ruleset.group);\n      const resolved = applyMessages(errors, ctx, messageResolver);\n      if (resolved) {\n        groupErrors.group = resolved;\n      }\n    }\n    if (ruleset.fields) {\n      const fieldsErrors = {};\n      Object.keys(ruleset.fields).forEach(field => {\n        var _a, _b;\n        const rules = (_b = (_a = ruleset.fields) === null || _a === void 0 ? void 0 : _a[field]) !== null && _b !== void 0 ? _b : [];\n        if (rules.length === 0) return;\n        const ctx = createContext(control, field);\n        const value = control.value[field];\n        const errors = evaluateRules(registry, value, ctx, rules);\n        const resolved = applyMessages(errors, ctx, messageResolver);\n        if (resolved) {\n          fieldsErrors[field] = resolved;\n        }\n      });\n      if (Object.keys(fieldsErrors).length > 0) {\n        groupErrors.fields = fieldsErrors;\n      }\n    }\n    return Object.keys(groupErrors).length > 0 ? {\n      pliant: groupErrors\n    } : null;\n  };\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}